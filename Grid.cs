/*
 
⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣿⣦⡀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⣷⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⣾⣿⣿⣿⣿⣿⣿⣿⡀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣧⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀
⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣠⣤⣤⣼⣿⣿⣿⣿⣿⣿⣿⣿⣷⠀⠀⠀⠀⠀
⠀⠀⠀⢀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀
⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀
⠀⠀⠀⠘⣿⣿⣿⣿⠟⠁⠀⠀⠀⠹⣿⣿⣿⣿⣿⠟⠁⠀⠀⠹⣿⣿⡿⠀⠀⠀⠀⠀
⠀⠀⠀⠀⣿⣿⣿⡇⠀⠀⠀⢼⣿⠀⢿⣿⣿⣿⣿⠀⣾⣷⠀⠀⢿⣿⣷⠀⠀⠀⠀⠀
⠀⠀⠀⢠⣿⣿⣿⣷⡀⠀⠀⠈⠋⢀⣿⣿⣿⣿⣿⡀⠙⠋⠀⢀⣾⣿⣿⠀⠀⠀⠀⠀
⢀⣀⣀⣀⣿⣿⣿⣿⣿⣶⣶⣶⣶⣿⣿⣿⣿⣾⣿⣷⣦⣤⣴⣿⣿⣿⣿⣤⠤⢤⣤⡄
⠈⠉⠉⢉⣙⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣇⣀⣀⣀⡀⠀
⠐⠚⠋⠉⢀⣬⡿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⣥⣀⡀⠈⠀⠈⠛
⠀⠀⠴⠚⠉⠀⠀⠀⠉⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠛⠋⠁⠀⠀⠀⠉⠛⠢⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀

Federico Zuffa
16.01.2026
Classe Passerelle
Projet Game of Life

*/
using System;
using System.Drawing;
using System.Net;

namespace Projet_GameOfLife
{
    internal class Grid
    {
        //Constantes

        //Champs
        private int _nbRow;
        private int _nbColumn;
        private bool[,] _cells;
        private bool[,] _nextCells;
        private int _width;
        private int _height;
        private int _cellSize;
        private int _cellWidth;
        private int _cellHeight;
        private Bitmap _bitmap;
        private Graphics _graphics;


        //Propriétés
        public int NbRow { get => _nbRow; set => _nbRow = value; }
        public int NbColumn { get => _nbColumn; set => _nbColumn = value; }
        public bool[,] Cells { get; }
        public bool[,] NextCells { get; }
        public int Width { get => _width; set => _width = value; }
        public int Height { get => _height; set => _height = value; }
        public int CellWidth { get => _cellWidth; set => _cellWidth = value; }
        public int CellHeight { get => _cellHeight; set => _cellHeight = value; }
        public Bitmap Bitmap { get => _bitmap; set => _bitmap = value; }
        public Graphics Graphics { get => _graphics; set => _graphics = value; }
        public int CellSize { get => _cellSize; set => _cellSize = value; }

        //Constructeurs

        public Grid(int nbRow, int nbColumn, int cellSize)
        {
            this.NbRow = nbRow;
            this.NbColumn = nbColumn;
            this.Cells = new bool[nbRow, nbColumn];
            this.NextCells = new bool[nbRow, nbColumn];
            this.CellSize = cellSize;
            //this.Width = width;
            //this.Height = height;
        }

        //Méthodes

        public bool GetCellState(int row, int col)
        {
            return Cells[row, col];
        }

        public void SetCellState(int row, int col, bool alive)
        {
            Cells[row, col] = alive;
        }

        public void Toggle(int row, int col)
        {
            Cells[row, col] = !Cells[row, col];
        }

        public void ResetGrid()
        {
            //Array.Clear(grid.Cells, 0, NbColumn);
            for (int i = 0; i < NbRow; i++)
            {
                for (int j = 0; j < NbColumn; j++)
                {
                    this.Cells[i, j] = false;
                    this.NextCells[i, j] = false;
                }
            }
        }

        public int CountNeighbors(int row, int col)
        {
            int nbOfNeighbors = 0;
            int newRow;
            int newCol;

            for (int dx = -1; dx <= 1; dx++)
            {
                for (int dy = -1; dy <= 1; dy++)
                {
                    if (dx != 0 || dy != 0)
                    { // ! à modifier si on veut une grille infinie ou thorique
                        newRow = row + dx;
                        newCol = col + dy;
                        if (newRow < NbRow && newCol < NbColumn && newRow >= 0 && newCol >= 0)
                        {
                            if (Cells[newRow, newCol])
                            {
                                nbOfNeighbors++;
                            }
                        }
                    }
                }
            }
            return nbOfNeighbors;
        }

        public void Step(Rules rule)
        {
            int aliveNeighbor;
            bool isAlive;

            for (int i = 0; i < NbRow; i++)
            {
                for (int j = 0; j < NbColumn; j++)
                {
                    aliveNeighbor = CountNeighbors(i, j);
                    isAlive = Cells[i, j];
                    NextCells[i, j] = rule.BasicComputeNextState(isAlive, aliveNeighbor);
                }
            }
            for (int i = 0; i < NbRow; i++)
            {
                for (int j = 0; j < NbColumn; j++)
                {
                    Cells[i, j] = NextCells[i, j];
                    NextCells[i, j] = false; //j'aurais pu resetGrid() aussi mais ça fait faire une double boucle supplémentaire
                }
            }
        }

        //PARTIE GRAPHIQUE

        public void InitializeBitMap(int width, int height)
        {
            this.Bitmap = new Bitmap(width, height);
            this.Graphics = Graphics.FromImage(this.Bitmap);

            this.CellWidth = width / NbColumn;
            this.CellHeight = height / NbRow;
        }

        public void DrawGrid()
        {
            this.Graphics.Clear(Color.Black);
            Pen gridPen = Pens.DarkGray;

            int dy = 0;
            int dx = 0;

            for (int i = 0; i < NbRow; i++)
            {
                dy = i * CellHeight;
                Graphics.DrawLine(gridPen, 0, dy, Bitmap.Width, dy);
            }
            for (int j = 0; j < NbColumn; j++)
            {
                dx = j * CellWidth;
                Graphics.DrawLine(gridPen, dx, 0, dx, Bitmap.Height);
            }
        }

        public void DrawCells()
        {
            Brush aliveBrush = Brushes.White;

            int dx = 0;
            int dy = 0;

            for (int i = 0; i < NbRow; i++)
            {
                for (int j = 0; j < NbColumn; j++)
                {
                    if (Cells[i, j])
                    {
                        dx = j * CellWidth;
                        dy = i * CellHeight;

                        Graphics.FillRectangle(aliveBrush, dx + 1, dy + 1, CellWidth - 1, CellHeight - 1);
                    }
                }
            }
        }

        public void Display()
        {
            DrawGrid();
            DrawCells();
        }

        public void ClearDisplay()
        {
            ResetGrid();
            Display();
        }

        public bool IsCellInGrid(int x, int y)
        {
            int col = x / CellWidth;
            int row = y / CellHeight;

            if (col < 0 || col >= NbColumn || row < 0 || row >= NbRow)
            {
                return false;
            }
            return true;
        }

        public int[] GetCellFromPixel(int x, int y)
        {
            int[] cellCoord = new int[2];

            int row = y / CellHeight;
            int col = x / CellWidth;

            if (IsCellInGrid(x, y))
            {
                cellCoord[0] = row;
                cellCoord[1] = col;
            }
            else
            {
                cellCoord[0] = -1;
                cellCoord[1] = -1;
            }
            return cellCoord;
        }

        public void ToggleFromPixel(int x, int y)
        {
            int[] cellToToggle = GetCellFromPixel(x, y);
            Toggle(cellToToggle[0], cellToToggle[1]);
        }
    }
}
