/*
 
⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣦⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣿⣦⡀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⣷⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⢀⣾⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⣾⣿⣿⣿⣿⣿⣿⣿⡀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣧⠀⠀⠀⠀⣼⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀
⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣠⣤⣤⣼⣿⣿⣿⣿⣿⣿⣿⣿⣷⠀⠀⠀⠀⠀
⠀⠀⠀⢀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀
⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀
⠀⠀⠀⠘⣿⣿⣿⣿⠟⠁⠀⠀⠀⠹⣿⣿⣿⣿⣿⠟⠁⠀⠀⠹⣿⣿⡿⠀⠀⠀⠀⠀
⠀⠀⠀⠀⣿⣿⣿⡇⠀⠀⠀⢼⣿⠀⢿⣿⣿⣿⣿⠀⣾⣷⠀⠀⢿⣿⣷⠀⠀⠀⠀⠀
⠀⠀⠀⢠⣿⣿⣿⣷⡀⠀⠀⠈⠋⢀⣿⣿⣿⣿⣿⡀⠙⠋⠀⢀⣾⣿⣿⠀⠀⠀⠀⠀
⢀⣀⣀⣀⣿⣿⣿⣿⣿⣶⣶⣶⣶⣿⣿⣿⣿⣾⣿⣷⣦⣤⣴⣿⣿⣿⣿⣤⠤⢤⣤⡄
⠈⠉⠉⢉⣙⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣇⣀⣀⣀⡀⠀
⠐⠚⠋⠉⢀⣬⡿⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⣥⣀⡀⠈⠀⠈⠛
⠀⠀⠴⠚⠉⠀⠀⠀⠉⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠛⠋⠁⠀⠀⠀⠉⠛⠢⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⣰⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀

Federico Zuffa
16.01.2026
Classe Passerelle
Projet Game of Life V1.3

*/
using System;
using System.Drawing;
using System.Net;
using System.Windows.Forms;

namespace Projet_GameOfLife
{
    internal class Grid
    {
        //Constantes

        //Champs
        private int _nbRow;
        private int _nbColumn;
        private bool[,] _cells;
        private bool[,] _nextCells;
        private int _width;
        private int _height;
        private int _cellSize;
        private Bitmap _bitmap;
        private Graphics _graphics;
        private bool _showGrid;
        private Rules _rules;
        private int offsetR;
        private int offsetC;


        //Propriétés
        public int NbRow { get => _nbRow; set => _nbRow = value; }
        public int NbColumn { get => _nbColumn; set => _nbColumn = value; }
        public bool[,] Cells { get; }
        public bool[,] NextCells { get; }
        public int Width { get => _width; set => _width = value; }
        public int Height { get => _height; set => _height = value; }
        public Bitmap Bitmap { get => _bitmap; set => _bitmap = value; }
        public Graphics Graphics { get => _graphics; set => _graphics = value; }
        public int CellSize { get => _cellSize; set => _cellSize = value; }
        public bool ShowGrid { get => _showGrid; set => _showGrid = value; }
        internal Rules Rules { get => _rules; set => _rules = value; }

        //Constructeurs

        public Grid(int nbRow, int nbColumn)
        {
            this.NbRow = nbRow;
            this.NbColumn = nbColumn;
            this.Cells = new bool[nbRow, nbColumn];
            this.NextCells = new bool[nbRow, nbColumn];
            Rules = new Rules();
            offsetR = nbRow / 2;
            offsetC = nbColumn / 2;
            //cellSize ?
        }

        //Méthodes

        public bool GetCellState(int row, int col)
        {
            return Cells[row, col];
        }

        public void SetCellState(int row, int col, bool alive)
        {
            Cells[row, col] = alive;
        }

        public void Toggle(int row, int col)
        {
            Cells[row, col] = !Cells[row, col];
        }

        public void ResetGrid()
        {
            //Array.Clear(grid.Cells, 0, NbColumn);
            for (int i = 0; i < NbRow; i++)
            {
                for (int j = 0; j < NbColumn; j++)
                {
                    this.Cells[i, j] = false;
                    this.NextCells[i, j] = false;
                }
            }
        }

        public int CountNeighbors(int row, int col)
        {
            int nbOfNeighbors = 0;
            int newRow;
            int newCol;

            for (int dx = -1; dx <= 1; dx++)
            {
                for (int dy = -1; dy <= 1; dy++)
                {
                    if (dx != 0 || dy != 0)
                    { // ! à modifier si on veut une grille infinie ou thorique
                        newRow = row + dx;
                        newCol = col + dy;
                        if (newRow < NbRow && newCol < NbColumn && newRow >= 0 && newCol >= 0)
                        {
                            if (Cells[newRow, newCol])
                            {
                                nbOfNeighbors++;
                            }
                        }
                    }
                }
            }
            return nbOfNeighbors;
        }

        public bool[,] CopyCurrentState()
        {
            bool[,] currentState = new bool[NbRow, NbColumn];

            currentState = (bool[,])Cells.Clone();

            return currentState;
        }

        public bool[,] PasteInitialState(bool[,] InitialState)
        {
            for (int i = 0; i < NbRow; i++)
            {
                for (int j = 0; j < NbColumn; j++)
                {
                    Cells[i, j] = InitialState[i, j];
                }
            }
            return Cells;
        }

        public void Step(string usedRule)
        {

            int aliveNeighbor;
            bool isAlive;

            for (int i = 0; i < NbRow; i++)
            {
                for (int j = 0; j < NbColumn; j++)
                {
                    aliveNeighbor = CountNeighbors(i, j);
                    isAlive = Cells[i, j];
                    if (usedRule == "ClassicRule")
                    {
                        NextCells[i, j] = Rules.ClassicComputeNextState(isAlive, aliveNeighbor);
                    }
                    else if (usedRule == "HighLifeRule")
                    {
                        NextCells[i, j] = Rules.HighLifeComputeNextState(isAlive, aliveNeighbor);
                    }
                }
            }
            for (int i = 0; i < NbRow; i++)
            {
                for (int j = 0; j < NbColumn; j++)
                {
                    Cells[i, j] = NextCells[i, j];
                    NextCells[i, j] = false;
                }
            }
        }

        //PARTIE GRAPHIQUE

        public void InitializeBitMap(int width, int height)
        {
            this.Bitmap = new Bitmap(width, height);
            this.Graphics = Graphics.FromImage(this.Bitmap);
        }

        public void DrawGrid()
        {
            this.Graphics.Clear(Color.Black);
            Pen gridPen = Pens.DarkGray;

            int dy = 0;
            int dx = 0;

            for (int i = 0; i <= NbRow; i++)
            {
                dy = i * CellSize;
                Graphics.DrawLine(gridPen, 0, dy, Bitmap.Width, dy);
            }
            for (int j = 0; j <= NbColumn; j++)
            {
                dx = j * CellSize;
                Graphics.DrawLine(gridPen, dx, 0, dx, Bitmap.Height);
            }
        }

        public void DrawCells()
        {
            Brush aliveBrush = Brushes.White;

            int dx = 0;
            int dy = 0;

            for (int i = 0; i < NbRow; i++)
            {
                for (int j = 0; j < NbColumn; j++)
                {
                    if (Cells[i, j])
                    {
                        dx = j * CellSize;
                        dy = i * CellSize;

                        Graphics.FillRectangle(aliveBrush, dx + 1, dy + 1, CellSize - 1, CellSize - 1);
                    }
                }
            }
        }

        public void Display()
        {
            this.Graphics.Clear(Color.Black);
            if (ShowGrid)
            {
                DrawGrid();
            }
            DrawCells();
        }

        public void ClearDisplay()
        {
            ResetGrid();
            Display();
        }

        public bool IsCellInGrid(int x, int y)
        {
            int col = x / CellSize;
            int row = y / CellSize;

            if (col < 0 || col >= NbColumn || row < 0 || row >= NbRow)
            {
                return false;
            }
            return true;
        }

        public int[] GetCellFromPixel(int x, int y)
        {
            int[] cellCoord = new int[2];

            int row = y / CellSize;
            int col = x / CellSize;

            if (IsCellInGrid(x, y))
            {
                cellCoord[0] = row;
                cellCoord[1] = col;
            }
            else
            {
                cellCoord[0] = -1;
                cellCoord[1] = -1;
            }
            return cellCoord;
        }

        public void ToggleFromPixel(int x, int y)
        {
            int[] cellToToggle = GetCellFromPixel(x, y);
            Toggle(cellToToggle[0], cellToToggle[1]);
        }


        // Configurations pré-définies

        public void Glider()
        {
            SetCellState(1 + offsetR, 2 + offsetC, true);
            SetCellState(2 + offsetR, 3 + offsetC, true);
            SetCellState(3 + offsetR, 1 + offsetC, true);
            SetCellState(3 + offsetR, 2 + offsetC, true);
            SetCellState(3 + offsetR, 3 + offsetC, true);
        }

        public void SmallExploder()
        {
            SetCellState(1 + offsetR, 2 + offsetC, true);
            SetCellState(2 + offsetR, 1 + offsetC, true);
            SetCellState(2 + offsetR, 2 + offsetC, true);
            SetCellState(2 + offsetR, 3 + offsetC, true);
            SetCellState(3 + offsetR, 1 + offsetC, true);
            SetCellState(3 + offsetR, 3 + offsetC, true);
            SetCellState(4 + offsetR, 2 + offsetC, true);
        }
        public void Exploder()
        {
            SetCellState(1 + offsetR, 1 + offsetC, true);
            SetCellState(1 + offsetR, 3 + offsetC, true);
            SetCellState(1 + offsetR, 5 + offsetC, true);
            SetCellState(2 + offsetR, 1 + offsetC, true);
            SetCellState(2 + offsetR, 5 + offsetC, true);
            SetCellState(3 + offsetR, 1 + offsetC, true);
            SetCellState(3 + offsetR, 5 + offsetC, true);
            SetCellState(4 + offsetR, 1 + offsetC, true);
            SetCellState(4 + offsetR, 5 + offsetC, true);
            SetCellState(5 + offsetR, 1 + offsetC, true);
            SetCellState(5 + offsetR, 3 + offsetC, true);
            SetCellState(5 + offsetR, 5 + offsetC, true);
        }
        public void Replicator()
        {
            SetCellState(1 + offsetR, 1 + offsetC, true);
            SetCellState(1 + offsetR, 2 + offsetC, true);
            SetCellState(2 + offsetR, 1 + offsetC, true);
            SetCellState(2 + offsetR, 2 + offsetC, true);
            SetCellState(3 + offsetR, 3 + offsetC, true);
            SetCellState(3 + offsetR, 4 + offsetC, true);
            SetCellState(4 + offsetR, 3 + offsetC, true);
            SetCellState(4 + offsetR, 4 + offsetC, true);
        }

        public void Factory()
        {
            SetCellState(67, 134, true);

            SetCellState(68, 132, true);
            SetCellState(68, 134, true);

            SetCellState(69, 122, true);
            SetCellState(69, 123, true);
            SetCellState(69, 130, true);
            SetCellState(69, 131, true);
            SetCellState(69, 144, true);
            SetCellState(69, 145, true);

            SetCellState(70, 121, true);
            SetCellState(70, 125, true);
            SetCellState(70, 130, true);
            SetCellState(70, 131, true);
            SetCellState(70, 144, true);
            SetCellState(70, 145, true);

            SetCellState(71, 110, true);
            SetCellState(71, 111, true);
            SetCellState(71, 120, true);
            SetCellState(71, 126, true);
            SetCellState(71, 130, true);
            SetCellState(71, 131, true);

            SetCellState(72, 110, true);
            SetCellState(72, 111, true);
            SetCellState(72, 120, true);
            SetCellState(72, 124, true);
            SetCellState(72, 126, true);
            SetCellState(72, 127, true);
            SetCellState(72, 132, true);
            SetCellState(72, 134, true);

            SetCellState(73, 120, true);
            SetCellState(73, 126, true);
            SetCellState(73, 134, true);

            SetCellState(74, 121, true);
            SetCellState(74, 125, true);

            SetCellState(75, 122, true);
            SetCellState(75, 123, true);
        }
        public void Soup()
        {
            Random rand = new Random();
            int randomValue;
            bool isAlive;

            for (int i = 0; i < NbRow / 3; i++)
            {
                for (int j = 0; j < NbColumn / 3; j++)
                {
                    randomValue = rand.Next(2);
                    if (randomValue == 0)
                    {
                        isAlive = false;
                    }
                    else
                    {
                        isAlive = true;
                    }
                    SetCellState(i + offsetR / 3, j + offsetC / 3, isAlive);
                }
            }
        }

    }
}
